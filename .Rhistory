x^n
}
pow
}
# make.power is a constructor function. See
(cub <- make.power(3))
(square <- make.power(2))
cube(3)
f <- function(x, y) {
x^2 + y / z
}
# Lexical Scopping and Function
make.power <- function(n){
pow <- function(x){
x^n
}
pow
}
# make.power is a constructor function. See
(cube <- make.power(3))
(square <- make.power(2))
cube(3)
square(3)
ls(environment(cube))
get("n", environment(cube))
ls(environment(square))
get("n", environment(square))
# Lexical vs Dynamic Scoping
y <- 10
f <- function(x){
y <- 2
y^2 + g(x)
}
g <- function(x){
x*y
}
# Calling
f(3)
# [1] 34 = 2^2 + 3*10
# Estimating the parameters
# Input initial values of mu and sigma = (0, 1)
p <- optim(c(mu = 0, sigma = 1), nLL)
library(optim)
# Scoping and Applicaiton on Optimization (Max Liklihood)
# Defining negative log likelihood function: nll()
# The key is to define data, params, fixed in the body (environment)
# of make.NegLogLik
make.NegLogLik <- function(data, fixed=c(FALSE,FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
# Take log of the normal to derive the objective fn.
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2) / (sigma^2)
# The objective function is:
-(a + b)
}
}
# Simulating normal variables and building constructor function
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLik(normals)
nLL
# <environment: 0x165b1a4> <- This is the enclosing environment for nll
ls(environment(nLL))
# [1] "data" "fixed" "params"
# We want to min the output of nLL()
P = c(50, 50); nLL(P) # returns 601.2165
P = c(10,10); nLL(P) # returns 362.3135
P = c(2,2); nLL(P) # returns 208.7917
P = c(1,2); nLL(P) # returns 201.7361 (lowest)
# Estimating the parameters
# Input initial values of mu and sigma = (0, 1)
p <- optim(c(mu = 0, sigma = 1), nLL)
View(p)
p$par
# Optim minimises a fn. by varying its parameters and output a list.
# The first argument of optim are the parameters to be varied, params
# the second argument is the function to be minimised
# The result is close to the true values which are (mu, sigma)=(1,2)
# Alternativly
n <- nlm(nLL,c(mu = 0, sigma = 1))
View(p)
n$estimate
# Fixing sigma = 2 by going to make.NegLogLik(),
# then we can use optimize() to deal with a single value
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum
#[1] 1.217775. Recall true mean is 1
# Fixing mean = 1
nLL <- make.NegLogLik(normals, c(1, FALSE))
optimize(nLL, c(1e-6, 10))$minimum
#[1] 1.800596. Recall true sigma is 2
# Plotting the likelihood function
# Fixing mean = 1 -> varying sigma
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Fixing sigma = 2 -> varying mu
nLL <- make.NegLogLik(normals, c(FALSE, 2))
x <- seq(0.5, 1.5, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Scoping and Applicaiton on Optimization (Max Liklihood)
# Defining negative log likelihood function: nll()
# The key is to define data, params, fixed in the body (environment)
# of make.NegLogLik
make.NegLogLik <- function(data, fixed=c(FALSE,FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
# Take log of the normal to derive the objective fn.
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2) / (sigma^2)
# The objective function is:
-(a + b)
}
}
# Simulating normal variables and building constructor function
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLik(normals)
nLL
# <environment: 0x165b1a4> <- This is the enclosing environment for nll
ls(environment(nLL))
# [1] "data" "fixed" "params"
# We want to min the output of nLL()
P = c(50, 50); nLL(P) # returns 601.2165
P = c(10,10); nLL(P) # returns 362.3135
P = c(2,2); nLL(P) # returns 208.7917
P = c(1,2); nLL(P) # returns 201.7361 (lowest)
# Estimating the parameters
# Input initial values of mu and sigma = (0, 1)
p <- optim(c(mu = 0, sigma = 1), nLL)
View(p)
p$par
# Optim minimises a fn. by varying its parameters and output a list.
# The first argument of optim are the parameters to be varied, params
# the second argument is the function to be minimised
# The result is close to the true values which are (mu, sigma)=(1,2)
# Alternativly
n <- nlm(nLL,c(mu = 0, sigma = 1))
View(p)
n$estimate
# Fixing sigma = 2 by going to make.NegLogLik(),
# then we can use optimize() to deal with a single value
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum
#[1] 1.217775. Recall true mean is 1
# Fixing mean = 1
nLL <- make.NegLogLik(normals, c(1, FALSE))
optimize(nLL, c(1e-6, 10))$minimum
#[1] 1.800596. Recall true sigma is 2
# Plotting the likelihood function
# Fixing mean = 1 -> varying sigma
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Fixing sigma = 2 -> varying mu
nLL <- make.NegLogLik(normals, c(FALSE, 2))
x <- seq(0.5, 1.5, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
rm(list=ls())
# Scoping and Applicaiton on Optimization (Max Liklihood)
# Defining negative log likelihood function: nll()
# The key is to define data, params, fixed in the body (environment)
# of make.NegLogLik
make.NegLogLik <- function(data, fixed=c(FALSE,FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
# Take log of the normal to derive the objective fn.
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2) / (sigma^2)
# The objective function is:
-(a + b)
}
}
# Simulating normal variables and building constructor function
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLik(normals)
nLL
# <environment: 0x165b1a4> <- This is the enclosing environment for nll
ls(environment(nLL))
# [1] "data" "fixed" "params"
# We want to min the output of nLL()
P = c(50, 50); nLL(P) # returns 601.2165
P = c(10,10); nLL(P) # returns 362.3135
P = c(2,2); nLL(P) # returns 208.7917
P = c(1,2); nLL(P) # returns 201.7361 (lowest)
# Estimating the parameters
# Input initial values of mu and sigma = (0, 1)
p <- optim(c(mu = 0, sigma = 1), nLL)
View(p)
p$par
# Optim minimises a fn. by varying its parameters and output a list.
# The first argument of optim are the parameters to be varied, params
# the second argument is the function to be minimised
# The result is close to the true values which are (mu, sigma)=(1,2)
# Alternativly
n <- nlm(nLL,c(mu = 0, sigma = 1))
View(p)
n$estimate
# Fixing sigma = 2 by going to make.NegLogLik(),
# then we can use optimize() to deal with a single value
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum
#[1] 1.217775. Recall true mean is 1
# Fixing mean = 1
nLL <- make.NegLogLik(normals, c(1, FALSE))
optimize(nLL, c(1e-6, 10))$minimum
#[1] 1.800596. Recall true sigma is 2
# Plotting the likelihood function
# Fixing mean = 1 -> varying sigma
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Fixing sigma = 2 -> varying mu
nLL <- make.NegLogLik(normals, c(FALSE, 2))
x <- seq(0.5, 1.5, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Scoping and Applicaiton on Optimization (Max Liklihood)
# Defining negative log likelihood function: nll()
# The key is to define data, params, fixed in the body (environment)
# of make.NegLogLik
make.NegLogLik <- function(data, fixed=c(FALSE,FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
# Take log of the normal to derive the objective fn.
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2) / (sigma^2)
# The objective function is:
-(a + b)
}
}
# Simulating normal variables and building constructor function
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLik(normals)
nLL
# <environment: 0x165b1a4> <- This is the enclosing environment for nll
ls(environment(nLL))
# [1] "data" "fixed" "params"
# We want to min the output of nLL()
P = c(50, 50); nLL(P) # returns 601.2165
P = c(10,10); nLL(P) # returns 362.3135
P = c(2,2); nLL(P) # returns 208.7917
P = c(1,2); nLL(P) # returns 201.7361 (lowest)
# Estimating the parameters
# Input initial values of mu and sigma = (0, 1)
p <- optim(c(mu = 0, sigma = 1), nLL)
View(p)
p$par
# Optim minimises a fn. by varying its parameters and output a list.
# The first argument of optim are the parameters to be varied, params
# the second argument is the function to be minimised
# The result is close to the true values which are (mu, sigma)=(1,2)
# Alternativly
n <- nlm(nLL,c(mu = 0, sigma = 1))
View(n)
n$estimate
# Fixing sigma = 2 by going to make.NegLogLik(),
# then we can use optimize() to deal with a single value
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum
#[1] 1.217775. Recall true mean is 1
# Fixing mean = 1
nLL <- make.NegLogLik(normals, c(1, FALSE))
optimize(nLL, c(1e-6, 10))$minimum
#[1] 1.800596. Recall true sigma is 2
# Plotting the likelihood function
# Fixing mean = 1 -> varying sigma
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Fixing sigma = 2 -> varying mu
nLL <- make.NegLogLik(normals, c(FALSE, 2))
x <- seq(0.5, 1.5, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
library(nlme)
library(nlm)
# Scoping and Applicaiton on Optimization (Max Liklihood)
# Defining negative log likelihood function: nll()
# The key is to define data, params, fixed in the body (environment)
# of make.NegLogLik
make.NegLogLik <- function(data, fixed=c(FALSE,FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
# Take log of the normal to derive the objective fn.
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2) / (sigma^2)
# The objective function is:
-(a + b)
}
}
# Simulating normal variables and building constructor function
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLik(normals)
nLL
# <environment: 0x165b1a4> <- This is the enclosing environment for nll
ls(environment(nLL))
# [1] "data" "fixed" "params"
# We want to min the output of nLL()
P = c(50, 50); nLL(P) # returns 601.2165
P = c(10,10); nLL(P) # returns 362.3135
P = c(2,2); nLL(P) # returns 208.7917
P = c(1,2); nLL(P) # returns 201.7361 (lowest)
# Estimating the parameters
# Input initial values of mu and sigma = (0, 1)
p <- optim(c(mu = 0, sigma = 1), nLL)
View(p)
p$par
# Optim minimises a function by varying its parameters and returns a list.
# The first argument of optim are the parameters to be varied, params here
# the second argument is the function to be minimised
# mu sigma
# 1.218239 1.787343
# The result is close to the true values which are (mu, sigma)=(1,2)
# Alternativly
n <- nlm(nLL,c(mu = 0, sigma = 1))
View(p)
n$estimate
# Fixing sigma = 2 by going to make.NegLogLik(),
# then we can use optimize() to deal with a single value
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum
#[1] 1.217775. Recall true mean is 1
# Fixing mean = 1
nLL <- make.NegLogLik(normals, c(1, FALSE))
optimize(nLL, c(1e-6, 10))$minimum
#[1] 1.800596. Recall true sigma is 2
# Plotting the likelihood function
# Fixing mean = 1 -> varying sigma
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Fixing sigma = 2 -> varying mu
nLL <- make.NegLogLik(normals, c(FALSE, 2))
x <- seq(0.5, 1.5, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
# Plotting (to be continue)
mu=seq(-2.5,2.5,length=100)
sigma=mu
f = outer(mu,sigma,function(mu, sigma, nLL,){
P = c(mu, sigma)
return(nLL(P))
})
contour(mu,sigma,f)
library(plotly)
g <- plot_ly(z = ~f) %>% add_surface()
g
?optim
?optimize
?nlm
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7). drop = TRUE]
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7), drop = TRUE]
# Plot drop_level
plot(drop_level)
rm(list=ls())
3134.07*6
knitr::opts_chunk$set(echo = TRUE)
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
par(mfrow=c(2,2)); plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7), drop = TRUE]
# Plot drop_level
plot(drop_level)
install.packages("jsonlite")
library(jsonlite)
# jsonlite is preloaded
# Definition of quandl_url
quandl_url <- "https://www.quandl.com/api/v3/datasets/WIKI/FB/data.json?auth_token=i83asDsiWUUyfoypkgMz"
# Import Quandl data: quandl_data
quandl_data <- fromJSON(quandl_url)
# Print structure of quandl_data
str(quandl_data)
View(quandl_data)
View(quandl_data)
class(quandl_data)
dataset_data
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
ordered(credit_factor, levels = c("CCC", "BBB", "BB", "B", "AA", "AAA"))
credit_factor[2] > credit_factor[1]
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
par(mfrow=c(2,2)); plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7), drop = TRUE]
# Plot drop_level
plot(drop_level)
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
ordered(credit_factor, levels = c("CCC", "BBB", "BB", "B", "AA", "AAA"))
"AAA" > "BBB"
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
par(mfrow=c(2,2)); plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7), drop = TRUE]
# Plot drop_level
plot(drop_level)
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
ordered(credit_factor, levels = c("CCC", "BBB", "BB", "B", "AA", "AAA"))
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
par(mfrow=c(2,2)); plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7), drop = TRUE]
# Plot drop_level
plot(drop_level)
credit_factor
AAA > BBB
credit_factor[2]
credit_factor[2] > credit_factor[1]
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)credit_factor
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
ordered(credit_factor, levels = c("CCC", "BBB", "BB", "B", "AA", "AAA"))
credit_factor[2] > credit_factor[1]
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
par(mfrow=c(2,2)); plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7), drop = TRUE]
# Plot drop_level
plot(drop_level)
credit_factor[2] > credit_factor[1]
AAA>AA
AAA>A
"AAA">"BBB"
class("AAA")
class(credit_factor[2] > credit_factor[1])
class(credit_factor[2])
# Factor
credit_rating <- c("BB", "AAA", "AA", "CCC", "AA", "AAA", "B", "BB")
credit_factor <- as.factor(credit_rating)
credit_factor <- ordered(credit_factor, levels = c("CCC", "BBB", "BB", "B", "AA", "AAA"))
credit_factor[2] > credit_factor[1]
# Remove the A bonds at positions 3 and 7. Don't drop the A level.
keep_level <- credit_factor[c(-3,-7)]
# Plot keep_level
par(mfrow=c(2,2)); plot(keep_level)
# Remove the A bonds at positions 3 and 7. Drop the A level.
drop_level <- credit_factor[c(-3,-7), drop = TRUE]
# Plot drop_level
plot(drop_level)
levels(credit_factor)
nlevel(credit_factor)
nlevels(credit_factor)
getwd()
setwd("/Users/nathaniellai/Desktop/datasciencecoursera")
setwd("/Users/nathaniellai/Desktop/datasciencecoursera/S2_R_Programming/specdata")
setwd("~/Desktop/datasciencecoursera/S2_R_Programming/specdataa")
setwd("~/S2_R_Programming/specdataa")
setwd("~/S2_R_Programming/specdata")
setwd("/Users/nathaniellai/Desktop/datasciencecoursera/S2_R_Programming/specdata")
